name: E2E Tests

on:
  schedule:
    - cron: "0 5 * * *"
  workflow_dispatch:
    inputs:
      debug_enabled:
        type: boolean
        description: "Run the build with tmate debugging enabled (https://github.com/marketplace/actions/debugging-with-tmate)"
        required: false
        default: false
      target_ref:
        type: string
        description: "Target ref to run the tests against"
        required: false
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
    paths:
      - "**.go"
      - ".github/workflows/**"
      - "test/testdata/**"

jobs:
  e2e-tests:
    # Run on schedule, unconditional workflow_dispatch,
    # or pull_request_target if the actor has write/admin permissions.
    if: >
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'pull_request_target'
    concurrency:
      group: ${{ github.workflow }}-${{ matrix.provider }}-${{ github.event.pull_request.number || github.ref_name }}
      cancel-in-progress: true

    name: e2e tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        provider: [providers, gitea_others]

    env:
      CONTROLLER_DOMAIN_URL: paac.paac-127-0-0-1.nip.io
      KO_DOCKER_REPO: registry.paac-127-0-0-1.nip.io
      KUBECONFIG: /home/runner/.kube/config.local
      TARGET_TEAM_SLUGS: "pipeline-as-code,pipeline-as-code-contributors"
      TEST_BITBUCKET_CLOUD_API_URL: https://api.bitbucket.org/2.0
      TEST_BITBUCKET_CLOUD_E2E_REPOSITORY: cboudjna/pac-e2e-tests
      TEST_BITBUCKET_CLOUD_USER: cboudjna
      TEST_BITBUCKET_SERVER_API_URL: ${{ secrets.BITBUCKET_SERVER_API_URL }}
      TEST_BITBUCKET_SERVER_E2E_REPOSITORY: PAC/pac-e2e-tests
      TEST_BITBUCKET_SERVER_TOKEN: ${{ secrets.BITBUCKET_SERVER_TOKEN }}
      TEST_BITBUCKET_SERVER_USER: pipelines
      TEST_BITBUCKET_SERVER_WEBHOOK_SECRET: ${{ secrets.BITBUCKET_SERVER_WEBHOOK_SECRET }}
      TEST_EL_URL: https://paac.paac-127-0-0-1.nip.io
      TEST_EL_WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
      TEST_GITEA_API_URL: http://localhost:3000
      TEST_GITEA_INTERNAL_URL: http://forgejo-http.forgejo.svc.cluster.local:3000
      TEST_GITEA_PASSWORD: pac
      TEST_GITEA_REPO_OWNER: pac/pac
      TEST_GITEA_SMEEURL: ${{ secrets.TEST_GITEA_SMEEURL }}
      TEST_GITEA_USERNAME: pac
      TEST_GITHUB_API_URL: api.github.com
      TEST_GITHUB_PRIVATE_TASK_NAME: task-remote
      TEST_GITHUB_PRIVATE_TASK_URL: https://github.com/openshift-pipelines/pipelines-as-code-e2e-tests-private/blob/main/remote_task.yaml
      TEST_GITHUB_REPO_OWNER_GITHUBAPP: openshift-pipelines/pipelines-as-code-e2e-tests
      TEST_GITHUB_REPO_OWNER_WEBHOOK: openshift-pipelines/pipelines-as-code-e2e-tests-webhook
      TEST_GITHUB_SECOND_API_URL: ghe.pipelinesascode.com
      TEST_GITHUB_SECOND_EL_URL: https://ghe.paac-127-0-0-1.nip.io
      TEST_GITHUB_SECOND_REPO_INSTALLATION_ID: 1
      TEST_GITHUB_SECOND_REPO_OWNER_GITHUBAPP: pipelines-as-code/e2e
      TEST_GITLAB_API_URL: https://gitlab.com
      TEST_GITLAB_PROJECT_ID: ${{ vars.TEST_GITLAB_PROJECT_ID }}
      TEST_BITBUCKET_CLOUD_TOKEN: ${{ secrets.BITBUCKET_CLOUD_TOKEN }}
      TEST_GITHUB_REPO_INSTALLATION_ID: ${{ vars.INSTALLATION_ID }}
      TEST_GITHUB_TOKEN: ${{ secrets.GH_APPS_TOKEN }}
      TEST_GITHUB_SECOND_TOKEN: ${{ secrets.TEST_GITHUB_SECOND_TOKEN }}
      TEST_GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ inputs.target_ref || github.event.pull_request.head.sha || github.sha }}

      # Step to check PR author's org membership and repo permissions.
      # This step will fail the job if checks do not pass, skipping subsequent steps.
      - name: Check user permissions on PRs
        if: github.event_name == 'pull_request_target'
        uses: actions/github-script@v8
        with:
          script: |
            if (!context || !context.payload || !context.payload.pull_request) {
              core.setFailed('Invalid GitHub context: missing required pull_request information');
              return;
            }

            async function run() {
              const actor = context.payload.pull_request.user.login;
              const repoOwner = context.repo.owner;
              const repoName = context.repo.repo;
              const targetOrg = context.repo.owner;

              core.info(`üîç Starting permission check for user: @${actor}`);
              core.info(`üìã Repository: ${repoOwner}/${repoName}`);
              core.info(`üè¢ Target organization: ${targetOrg}`);

              // Condition 1: Check if the user is a trusted bot.
              const trustedBots = ["dependabot[bot]", "renovate[bot]"];
              core.info(`ü§ñ Checking if @${actor} is a trusted bot...`);
              core.info(`   Trusted bots list: ${trustedBots.join(', ')}`);

              if (trustedBots.includes(actor)) {
                core.info(`‚úÖ Condition met: User @${actor} is a trusted bot. Proceeding.`);
                return; // Success
              }
              core.info(`   ‚ùå User @${actor} is not a trusted bot.`);

              // Condition 2: Check for public membership in the target organization.
              core.info(`\nüë• Condition 2: Checking organization and team membership...`);
              core.info(
                `User @${actor} is not a trusted bot. Checking for membership in '${targetOrg}'...`,
              );
              try {
                // Optional: check membership in one or more org teams (set TARGET_TEAM_SLUGS as comma-separated slugs in workflow env)
                const teamSlugsEnv = process.env.TARGET_TEAM_SLUGS || "";
                const teamSlugs = teamSlugsEnv
                  .split(",")
                  .map((s) => s.trim())
                  .filter(Boolean);

                core.info(`üîß TARGET_TEAM_SLUGS environment variable: "${teamSlugsEnv}"`);
                core.info(`üìù Parsed team slugs: [${teamSlugs.join(', ')}]`);

                if (teamSlugs.length > 0) {
                  core.info(`üîç Checking team membership for ${teamSlugs.length} team(s)...`);
                  for (const team_slug of teamSlugs) {
                    core.info(`   Checking team: ${team_slug}...`);
                    try {
                      const membership = await github.rest.teams.getMembershipForUserInOrg({
                        org: targetOrg,
                        team_slug,
                        username: actor,
                      });
                      core.info(`   API response for team '${team_slug}': ${JSON.stringify(membership.data)}`);
                      if (
                        membership &&
                        membership.data &&
                        membership.data.state === "active"
                      ) {
                        core.info(
                          `‚úÖ Condition met: User @${actor} is a member of team '${team_slug}' in '${targetOrg}'. Proceeding.`,
                        );
                        return; // Success
                      } else {
                        core.info(`   ‚ö†Ô∏è Team membership found but state is not 'active': ${membership.data.state}`);
                      }
                    } catch (err) {
                      // Not a member of this team or team doesn't exist ‚Äî continue to next
                      core.info(
                        `   ‚ùå User @${actor} is not a member of team '${team_slug}' (or team not found). Error: ${err.message}`,
                      );
                    }
                  }
                  // If we tried team checks and none matched, continue to next org membership checks
                  core.info(
                    `‚ìò User @${actor} is not a member of any configured teams in '${targetOrg}'. Falling back to org membership checks.`,
                  );
                } else {
                  core.info(`‚ÑπÔ∏è No teams configured in TARGET_TEAM_SLUGS. Skipping team membership checks.`);
                }
                core.info(`üè¢ Checking organization membership for @${actor} in '${targetOrg}'...`);
                try {
                  core.info(`   Attempting checkMembershipForUser API call...`);
                  await github.rest.orgs.checkMembershipForUser({
                    org: targetOrg,
                    username: actor,
                  });
                  core.info(
                    `‚úÖ Condition met: User @${actor} is a member of '${targetOrg}'. Proceeding.`,
                  );
                  return; // Success
                } catch (err) {
                  // Try public membership as fallback
                  core.info(`   ‚ùå Private membership check failed: ${err.message}`);
                  core.info(`   Attempting checkPublicMembershipForUser API call...`);
                  try {
                    await github.rest.orgs.checkPublicMembershipForUser({
                      org: targetOrg,
                      username: actor,
                    });
                    core.info(
                      `‚úÖ Condition met: User @${actor} is a public member of '${targetOrg}'. Proceeding.`,
                    );
                    return; // Success
                  } catch (publicErr) {
                    // Neither private nor public member - will be caught by outer catch
                    core.info(`   ‚ùå Public membership check failed: ${publicErr.message}`);
                    throw publicErr;
                  }
                }
              } catch (error) {
                // This is not a failure, just one unmet condition. Log and continue.
                core.info(
                  `‚ìò User @${actor} is not a public member of '${targetOrg}'. Checking repository permissions as a fallback.`,
                );
              }

              // Condition 3: Check for write/admin permission on the repository.
              core.info(`\nüîê Condition 3: Checking repository collaborator permissions...`);
              try {
                core.info(`   Attempting getCollaboratorPermissionLevel API call...`);
                const response = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: repoOwner,
                  repo: repoName,
                  username: actor,
                });

                const permission = response.data.permission;
                core.info(`   User @${actor} has '${permission}' permission on ${repoOwner}/${repoName}`);

                if (permission === "admin" || permission === "write") {
                  core.info(
                    `‚úÖ Condition met: User @${actor} has '${permission}' repository permission. Proceeding.`,
                  );
                  return; // Success
                } else {
                  // If we reach here, no conditions were met. This is the final failure.
                  core.info(`   ‚ùå Permission '${permission}' is insufficient (requires 'write' or 'admin')`);
                  core.setFailed(
                    `‚ùå Permission check failed. User @${actor} did not meet any required conditions (trusted bot, org member, or repo write access).`,
                  );
                  return;
                }
              } catch (error) {
                // This error means they are not even a collaborator.
                core.info(`   ‚ùå Collaborator permission check failed: ${error.message}`);
                core.setFailed(
                  `‚ùå Permission check failed. User @${actor} is not a collaborator on this repository and did not meet other conditions.`,
                );
                return;
              }
            }

            run().catch(err => {
              core.error(`üí• Unexpected error during permission check: ${err.message}`);
              core.error(`   Stack trace: ${err.stack}`);
              core.setFailed(`Unexpected error during permission check: ${err.message}`);
            });

      - uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"

      - uses: ko-build/setup-ko@v0.9

      # Start binary build in background as soon as possible so we can optimize
      # the run of e2e when it's start later on
      - name: Build binaries in parallel with cluster installation
        run: |
          nohup make allbinaries > /tmp/binary-build.log 2>&1 &
          echo $! > /tmp/binary-build.pid

      - name: Install gosmee
        uses: jaxxstorm/action-install-gh-release@v2.1.0
        with:
          repo: chmouel/gosmee

      - name: Install Snazy
        uses: jaxxstorm/action-install-gh-release@v2.1.0
        with:
          repo: chmouel/snazy

      - name: Install minica
        run: |
          go install github.com/jsha/minica@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Clone startpaac
        uses: actions/checkout@v6
        with:
          repository: openshift-pipelines/startpaac
          path: startpaac

      - name: Run gosmee for main controller
        run: |
          nohup gosmee client --saveDir /tmp/gosmee-replay ${{ secrets.PYSMEE_URL }} "https://${CONTROLLER_DOMAIN_URL}" &

      - name: Run gosmee for main controller (Gitea)
        run: |
          nohup gosmee client --saveDir /tmp/gosmee-replay ${{ secrets.TEST_GITEA_SMEEURL }} "https://${CONTROLLER_DOMAIN_URL}" &

      - name: Run gosmee for second controller (GHE)
        if: matrix.provider == 'providers'
        run: |
          nohup gosmee client --saveDir /tmp/gosmee-replay-ghe ${{ secrets.TEST_GITHUB_SECOND_SMEE_URL }} "https://ghe.paac-127-0-0-1.nip.io" &

      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.debug_enabled }}
        with:
          detached: true
          limit-access-to-actor: true

      - name: Start installing cluster with startpaac
        env:
          PAC_DIR: ${{ github.workspace }}
          PAAC_DOMAIN: paac-127-0-0-1.nip.io
          TEST_GITEA_SMEEURL: ${{ secrets.TEST_GITEA_SMEEURL }}
        run: |
          # Create real secrets for startpaac (not dummy)
          mkdir -p ~/secrets
          echo "${{ vars.APPLICATION_ID }}" > ~/secrets/github-application-id
          echo "${{ secrets.APP_PRIVATE_KEY }}" > ~/secrets/github-private-key
          echo "${{ secrets.WEBHOOK_SECRET }}" > ~/secrets/webhook.secret
          echo "${{ secrets.PYSMEE_URL }}" > ~/secrets/smee

          # Create second controller secrets
          mkdir -p ~/secrets-second
          echo "${{ vars.TEST_GITHUB_SECOND_APPLICATION_ID }}" > ~/secrets-second/github-application-id
          echo "${{ secrets.TEST_GITHUB_SECOND_PRIVATE_KEY }}" > ~/secrets-second/github-private-key
          echo "${{ secrets.TEST_GITHUB_SECOND_WEBHOOK_SECRET }}" > ~/secrets-second/webhook.secret
          echo "${{ secrets.TEST_GITHUB_SECOND_SMEE_URL }}" > ~/secrets-second/smee

          export PAC_SECRET_FOLDER=~/secrets
          export PAC_SECOND_SECRET_FOLDER=~/secrets-second
          export TARGET_HOST=local

          cd startpaac
          ./startpaac --ci -a

      - name: Install minica CA certificate to system trust store
        run: |
          set -x
          echo "=== Installing minica CA certificate to system trust store ==="
          if [ -f /tmp/certs/minica.pem ]; then
            sudo mkdir -p /usr/local/share/ca-certificates/
            sudo cp /tmp/certs/minica.pem /usr/local/share/ca-certificates/minica.crt
            sudo update-ca-certificates
            echo "‚úì CA certificate installed to system trust store"

            # Verify installation
            ls -la /usr/local/share/ca-certificates/minica.crt
            echo "System will now trust HTTPS connections to *.127-0-0-1.nip.io domains"
          else
            echo "‚úó ERROR: /tmp/certs/minica.pem not found"
            echo "startpaac should have created this file"
            exit 1
          fi

      - name: Configure git to skip TLS verification
        run: |
          git config --global http.sslVerify false

      - name: Install gotestsum
        run: |
          go install gotest.tools/gotestsum@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      # Adjusted step-level conditions based on the new job-level logic
      - name: Run E2E Tests
        # This step runs for schedule, PR target (if job started), or workflow_dispatch (if job started)
        # Remove the old label check which is no longer relevant for triggering.
        if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request_target' }}
        env:
          TEST_PROVIDER: ${{ matrix.provider }}
          TEST_BITBUCKET_CLOUD_TOKEN: ${{ secrets.BITBUCKET_CLOUD_TOKEN }}
          TEST_EL_WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
          TEST_GITEA_SMEEURL: ${{ secrets.TEST_GITEA_SMEEURL }}
          TEST_GITHUB_REPO_INSTALLATION_ID: ${{ vars.INSTALLATION_ID }}
          TEST_GITHUB_TOKEN: ${{ secrets.GH_APPS_TOKEN }}
          TEST_GITHUB_SECOND_TOKEN: ${{ secrets.TEST_GITHUB_SECOND_TOKEN }}
          TEST_GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          TEST_BITBUCKET_SERVER_TOKEN: ${{ secrets.BITBUCKET_SERVER_TOKEN }}
          TEST_BITBUCKET_SERVER_API_URL: ${{ secrets.BITBUCKET_SERVER_API_URL }}
          TEST_BITBUCKET_SERVER_WEBHOOK_SECRET: ${{ secrets.BITBUCKET_SERVER_WEBHOOK_SECRET }}
        run: |
          # TODO: remove this installation after testing.
          # The workflow uses the file in main so gotestsum installation step is not being triggered.
          go install gotest.tools/gotestsum@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

          ./hack/gh-workflow-ci.sh run_e2e_tests

      - name: Run E2E Tests on nightly
        # This step still runs specifically for schedule or workflow_dispatch
        if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
        env:
          NIGHTLY_E2E_TEST: "true"
          TEST_PROVIDER: ${{ matrix.provider }}
          TEST_BITBUCKET_CLOUD_TOKEN: ${{ secrets.BITBUCKET_CLOUD_TOKEN }}
          TEST_EL_WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
          TEST_GITEA_SMEEURL: ${{ secrets.TEST_GITEA_SMEEURL }}
          TEST_GITHUB_REPO_INSTALLATION_ID: ${{ vars.INSTALLATION_ID }}
          TEST_GITHUB_TOKEN: ${{ secrets.GH_APPS_TOKEN }}
          TEST_GITHUB_SECOND_TOKEN: ${{ secrets.TEST_GITHUB_SECOND_TOKEN }}
          TEST_GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
          TEST_BITBUCKET_SERVER_TOKEN: ${{ secrets.BITBUCKET_SERVER_TOKEN }}
          TEST_BITBUCKET_SERVER_API_URL: ${{ secrets.BITBUCKET_SERVER_API_URL }}
          TEST_BITBUCKET_SERVER_WEBHOOK_SECRET: ${{ secrets.BITBUCKET_SERVER_WEBHOOK_SECRET }}
        run: |
          ./hack/gh-workflow-ci.sh run_e2e_tests

      - name: Generate E2E Test Summary
        if: ${{ always() }}
        run: |
          echo "## üß™ E2E Test Results - ${{ matrix.provider }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ ! -f /tmp/e2e-results.json ]]; then
            echo "‚ö†Ô∏è No test results found" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Parse JSON and generate summary table using Python
          python3 << 'EOF' >> $GITHUB_STEP_SUMMARY
          import json
          import sys

          results = {}
          failures = {}

          with open('/tmp/e2e-results.json', 'r') as f:
              for line in f:
                  try:
                      entry = json.loads(line.strip())
                      action = entry.get('Action')
                      test = entry.get('Test')
                      pkg = entry.get('Package', '')

                      if not test:
                          continue

                      key = test

                      if action in ('pass', 'fail', 'skip'):
                          elapsed = entry.get('Elapsed', 0)
                          results[key] = {
                              'status': action,
                              'elapsed': elapsed,
                              'package': pkg
                          }
                      elif action == 'output' and key in results and results[key]['status'] == 'fail':
                          output = entry.get('Output', '')
                          if output and not output.startswith('=== ') and not output.startswith('--- '):
                              if key not in failures:
                                  failures[key] = []
                              failures[key].append(output.strip())
                  except json.JSONDecodeError:
                      continue

          # Count stats
          passed = sum(1 for r in results.values() if r['status'] == 'pass')
          failed = sum(1 for r in results.values() if r['status'] == 'fail')
          skipped = sum(1 for r in results.values() if r['status'] == 'skip')
          total = len(results)

          # Print summary header
          if failed > 0:
              print("### ‚ùå Tests Failed")
          elif total == 0:
              print("### ‚ö†Ô∏è No Tests Run")
          else:
              print("### ‚úÖ All Tests Passed")
          print()

          # Stats table
          print("| Metric | Count |")
          print("|--------|-------|")
          print(f"| ‚úÖ Passed | {passed} |")
          print(f"| ‚ùå Failed | {failed} |")
          print(f"| ‚è≠Ô∏è Skipped | {skipped} |")
          print(f"| üìä Total | {total} |")
          print()

          # Detailed results table
          print("<details>")
          print("<summary>üìã All Test Results</summary>")
          print()
          print("| Status | Test Name | Duration | Failure Reason |")
          print("|--------|-----------|----------|----------------|")

          # Sort: failures first, then by name
          sorted_results = sorted(results.items(), key=lambda x: (x[1]['status'] != 'fail', x[0]))

          for test, data in sorted_results:
              status_icon = {'pass': '‚úÖ', 'fail': '‚ùå', 'skip': '‚è≠Ô∏è'}.get(data['status'], '‚ùì')
              elapsed = f"{data['elapsed']:.2f}s" if data['elapsed'] else '-'
              failure_reason = ''
              if data['status'] == 'fail' and test in failures:
                  # Get first meaningful line of failure
                  for line in failures[test][:3]:
                      if line and not line.startswith('FAIL'):
                          failure_reason = line[:80].replace('|', '\\|')
                          if len(line) > 80:
                              failure_reason += '...'
                          break
              print(f"| {status_icon} | `{test}` | {elapsed} | {failure_reason} |")

          print()
          print("</details>")
          print()

          # Show failed test details
          if failed > 0:
              print("<details>")
              print("<summary>üî¥ Failed Test Details</summary>")
              print()
              for test, data in sorted_results:
                  if data['status'] == 'fail' and test in failures:
                      print(f"#### `{test}`")
                      print("```")
                      print('\n'.join(failures[test][:20]))
                      print("```")
                      print()
              print("</details>")
              print()

          # Slowest tests
          slow_tests = [(t, d) for t, d in results.items() if d['elapsed'] and d['elapsed'] > 30]
          slow_tests.sort(key=lambda x: x[1]['elapsed'], reverse=True)

          if slow_tests:
              print("### üê¢ Slowest Tests")
              print()
              print("| Test Name | Duration |")
              print("|-----------|----------|")
              for test, data in slow_tests[:10]:
                  print(f"| `{test}` | {data['elapsed']:.2f}s |")
              print()
          EOF

      - name: Publish E2E Test Report
        uses: mikepenz/action-junit-report@v5
        if: ${{ always() }}
        with:
          report_paths: /tmp/e2e-results.xml
          include_passed: true
          detailed_summary: true
          summary: true

      - name: Collect logs
        if: ${{ always() }}
        env:
          TEST_GITEA_SMEEURL: ${{ secrets.TEST_GITEA_SMEEURL }}
          TEST_GITHUB_SECOND_SMEE_URL: ${{ secrets.TEST_GITHUB_SECOND_SMEE_URL }}
        run: |
          ./hack/gh-workflow-ci.sh collect_logs

      - name: Show controllers/watcher logs with Snazy
        if: ${{ always() }}
        run: |
          ./hack/gh-workflow-ci.sh output_logs

      - name: Upload artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v6
        with:
          name: logs-e2e-tests-${{ matrix.provider }}
          path: |
            /tmp/logs
            /tmp/e2e-results.xml
            /tmp/e2e-results.json

      - name: Report Status
        if: ${{ always() && github.ref_name == 'main' && github.event_name == 'schedule' }}
        uses: ravsamhq/notify-slack-action@v2
        with:
          status: ${{ job.status }}
          notify_when: "failure"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
