---
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: go-testing
  annotations:
    pipelinesascode.tekton.dev/max-keep-runs: "2"
    pipelinesascode.tekton.dev/cancel-in-progress: "true"
    pipelinesascode.tekton.dev/on-event: "pull_request"
    pipelinesascode.tekton.dev/on-target-branch: "[*]"
    pipelinesascode.tekton.dev/on-path-change: "[***/*.go]"
spec:
  params:
    - name: repo_url
      value: "{{repo_url}}"
    - name: revision
      value: "{{revision}}"
  pipelineSpec:
    params:
      - name: repo_url
      - name: revision
    tasks:
      - name: go
        taskSpec:
          workspaces:
            - name: source
          steps:
            - name: fetch-repo
              ref:
                resolver: http
                params:
                  - name: url
                    value: https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/refs/heads/main/.tekton/stepactions/git-clone.yaml
              params:
                - name: output-path
                  value: $(workspaces.source.path)
                - name: url
                  value: "$(params.repo_url)"
                - name: revision
                  value: "$(params.revision)"
            - name: cache-fetch
              ref:
                resolver: http
                params:
                  - name: url
                    value: https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/refs/heads/main/.tekton/tasks/cache-fetch.yaml
              params:
                - name: patterns
                  value: ["**go.mod", "**go.sum"]
                - name: source
                  value: oci://image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/cache-go:{{hash}}
                - name: cachePath
                  value: $(workspaces.source.path)/go-build-cache
                - name: workingdir
                  value: $(workspaces.source.path)
            - name: unittest
              # we get bumped out when usingh the official image with docker.io
              # ratelimit so workaround this.
              image: golang:1.25
              env:
                - name: GOCACHE
                  value: $(workspaces.source.path)/go-build-cache/cache
                - name: GOMODCACHE
                  value: $(workspaces.source.path)/go-build-cache/mod
              workingDir: $(workspaces.source.path)
              script: |
                #!/usr/bin/env bash
                set -eux
                git config --global --add safe.directory $(workspaces.source.path)
                export GO_TEST_FLAGS="-v -race -coverprofile=coverage.txt -covermode=atomic"
                make test

            - name: coverage
              image: golang:1.25
              env:
                - name: HUB_TOKEN
                  valueFrom:
                    secretKeyRef:
                      name: "nightly-ci-github-hub-token"
                      key: "hub-token"
                - name: UPLOADER_UPLOAD_CREDENTIALS
                  valueFrom:
                    secretKeyRef:
                      name: "uploader-upload-credentials"
                      key: "credentials"
                - name: UPLOADER_PUBLIC_URL
                  valueFrom:
                    secretKeyRef:
                      name: "uploader-upload-credentials"
                      key: "public_url"
              workingDir: $(workspaces.source.path)
              script: |
                #!/usr/bin/env bash
                set -eux
                # Download and extract go-better-html-coverage
                curl -sSfL https://github.com/chmouel/go-better-html-coverage/releases/download/v1.2.0/go-better-html-coverage-1.2.0-linux-arm64.tar.gz | tar -xzf - -C /tmp

                # Generate HTML coverage
                /tmp/go-better-html-coverage -profile coverage.txt -o coverage.html -n -q

                # Upload to server
                mkdir -p {{ pull_request_number }}
                mv coverage.html {{ pull_request_number }}/
                tar czf - {{ pull_request_number }} | curl -u ${UPLOADER_UPLOAD_CREDENTIALS} \
                  -F path=coverage -F targz=true -X POST -F file=@- http://uploader:8080/upload

                # Post GitHub status
                set +x
                curl -H "Authorization: Bearer ${HUB_TOKEN}" \
                  -H 'Accept: application/vnd.github.v3+json' \
                  -X POST "https://api.github.com/repos/{{repo_owner}}/{{repo_name}}/statuses/{{revision}}" \
                  -d "{\"state\": \"success\", \"target_url\": \"${UPLOADER_PUBLIC_URL}/coverage/{{ pull_request_number }}/coverage.html\", \"description\": \"HTML Coverage Report\", \"context\": \"Pipelines as Code Coverage\"}"
            - name: lint
              image: golangci/golangci-lint:latest
              workingDir: $(workspaces.source.path)
              env:
                - name: GOCACHE
                  value: $(workspaces.source.path)/go-build-cache/cache
                - name: GOMODCACHE
                  value: $(workspaces.source.path)/go-build-cache/mod
                - name: GOLANGCILINT_CACHE
                  value: $(workspaces.source.path)/go-build-cache/golangci-cache
              script: |
                #!/usr/bin/env bash
                set -eux
                make lint-go
            - name: cache-upload
              ref:
                resolver: http
                params:
                  - name: url
                    value: https://raw.githubusercontent.com/openshift-pipelines/pipelines-as-code/refs/heads/main/.tekton/tasks/cache-upload.yaml
              params:
                - name: patterns
                  value: ["**go.mod", "**go.sum"]
                - name: target
                  value: oci://image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/cache-go:{{hash}}
                - name: fetched
                  value: $(tasks.cached-fetch.results.fetched)
                - name: cachePath
                  value: $(workspaces.source.path)/go-build-cache
                - name: workingdir
                  value: $(workspaces.source.path)
                - name: force-cache-upload
                  value: "false"
        workspaces:
          - name: source
            workspace: source
    workspaces:
      - name: source
  workspaces:
    - name: source
      emptyDir: {}
